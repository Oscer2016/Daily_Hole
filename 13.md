### 一个类的五种特殊成员函数
1.拷贝构造函数  （copy constructor）
2.拷贝赋值运算符（copy-assignment operator）
3.移动构造函数  （move constructor)
4.移动赋值运算符（move-assignment operator）
5.析构函数      （destructor)

两个构造函数都是针对**用另一个对象初始化时**的操作，而两个赋值运算符都是针对**用另一个对象赋值时**。
析构函数则是针对**销毁对象时**的操作。

简单说，对于我们接触的类,比如最熟悉的string,在使用时都有两种典型的操作。
```cpp

string b("hello");
string a(b);
string a = b;

```
一开始觉得，这两种操作有啥区别，反正最后结果都一样。
但是这两种正是对应了我们上文说的**用另一个对象初始化**和**用另一个对象赋值**。
也就是**直接初始化** 和 **拷贝初始化**。  

需要注意的是，对于**拷贝初始化**，还有几种情况：
1.将一个对象作为实参传递给函数**非引用类型**的形参。  
2.从返回值类型为**非引用类型**的函数中返回对象。  
3.用**花括号列表初始化数组中的元素**或一个聚合类中的成员。  

一个简单的拷贝构造函数例子：
```cpp
class Student{
    Student(int num): _num(num) {} //构造函数
    Student(const Student&);       //拷贝构造函数
}；
```
可以看到，重点在于参数是const & 必须是一个引用类型（当然如果还其他有默认值的参数也可以）。
为什么呢？
这就是我们上面注意点1的作用了，由于在传参时，如果形参不是引用，那么就会发生**拷贝初始化**，也就是**调用拷贝构造函数**，但是拷贝构造函数的形参依然不是引用，又要**拷贝初始化**，这就形成了一个没有出口的递归：
